{"version":3,"file":"app-game.444fd9ea.js","sources":["../../node_modules/fflate/esm/browser.js","../../src/another/resources/strings.ts","../../src/another/resources/index.ts","../../src/another/vm/palette.ts","../../src/another/vm/canvas.ts","../../src/another/vm/memory.ts","../../src/another/vm/controls.ts","../../node_modules/@free-side/audioworklet-polyfill/dist/audioworklet-polyfill.js","../../src/another/sound/SfxPlayer.ts","../../src/another/vm/sound.ts","../../src/another/vm/opcodes.ts","../../src/another/vm/vm.ts","../../node_modules/stats.js/build/stats.min.js","../../src/another/vm/engine.ts","../../src/pages/app-game.ts"],"sourcesContent":["// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","export const enum STRINGS_LANGUAGE {\r\n  EN = 0,\r\n  FR = 1,\r\n}\r\n\r\nexport const strings_en = {\r\n  0x001: 'P E A N U T  3000',\r\n  0x002:\r\n    'Copyright  } 1990 Peanut Computer, Inc.\\nAll rights reserved.\\n\\nCDOS Version 5.01',\r\n  0x003: '2',\r\n  0x004: '3',\r\n  0x005: '.',\r\n  0x006: 'A',\r\n  0x007: '@',\r\n  0x008: 'PEANUT 3000',\r\n  0x00a: 'R',\r\n  0x00b: 'U',\r\n  0x00c: 'N',\r\n  0x00d: 'P',\r\n  0x00e: 'R',\r\n  0x00f: 'O',\r\n  0x010: 'J',\r\n  0x011: 'E',\r\n  0x012: 'C',\r\n  0x013: 'T',\r\n  0x014: 'Shield 9A.5f Ok',\r\n  0x015: 'Flux % 5.0177 Ok',\r\n  0x016: 'CDI Vector ok',\r\n  0x017: ' %%%ddd ok',\r\n  0x018: 'Race-Track ok',\r\n  0x019: 'SYNCHROTRON',\r\n  0x01a:\r\n    'E: 23%\\ng: .005\\n\\nRK: 77.2L\\n\\nopt: g+\\n\\n Shield:\\n1: OFF\\n2: ON\\n3: ON\\n\\nP~: 1\\n',\r\n  0x01b: 'ON',\r\n  0x01c: '-',\r\n  0x021: '|',\r\n  0x022: '--- Theoretical study ---',\r\n  0x023: ' THE EXPERIMENT WILL BEGIN IN    SECONDS',\r\n  0x024: '  20',\r\n  0x025: '  19',\r\n  0x026: '  18',\r\n  0x027: '  4',\r\n  0x028: '  3',\r\n  0x029: '  2',\r\n  0x02a: '  1',\r\n  0x02b: '  0',\r\n  0x02c: \"L E T ' S   G O\",\r\n  0x031: '- Phase 0:\\nINJECTION of particles\\ninto synchrotron',\r\n  0x032: '- Phase 1:\\nParticle ACCELERATION.',\r\n  0x033: '- Phase 2:\\nEJECTION of particles\\non the shield.',\r\n  0x034: 'A  N  A  L  Y  S  I  S',\r\n  0x035:\r\n    '- RESULT:\\nProbability of creating:\\n ANTIMATTER: 91.V %\\n NEUTRINO 27:  0.04 %\\n NEUTRINO 424: 18 %\\n',\r\n  0x036: '   Practical verification Y/N ?',\r\n  0x037: 'SURE ?',\r\n  0x038:\r\n    'MODIFICATION OF PARAMETERS\\nRELATING TO PARTICLE\\nACCELERATOR (SYNCHROTRON).',\r\n  0x039: '       RUN EXPERIMENT ?',\r\n  0x03c: 't---t',\r\n  0x03d: '000 ~',\r\n  0x03e: '.20x14dd',\r\n  0x03f: 'gj5r5r',\r\n  0x040: 'tilgor 25%',\r\n  0x041: '12% 33% checked',\r\n  0x042: 'D=4.2158005584',\r\n  0x043: 'd=10.00001',\r\n  0x044: '+',\r\n  0x045: '*',\r\n  0x046: '% 304',\r\n  0x047: 'gurgle 21',\r\n  0x048: '{{{{',\r\n  0x049: 'Delphine Software',\r\n  0x04a: 'By Eric Chahi',\r\n  0x04b: '  5',\r\n  0x04c: '  17',\r\n  0x12c: '0',\r\n  0x12d: '1',\r\n  0x12e: '2',\r\n  0x12f: '3',\r\n  0x130: '4',\r\n  0x131: '5',\r\n  0x132: '6',\r\n  0x133: '7',\r\n  0x134: '8',\r\n  0x135: '9',\r\n  0x136: 'A',\r\n  0x137: 'B',\r\n  0x138: 'C',\r\n  0x139: 'D',\r\n  0x13a: 'E',\r\n  0x13b: 'F',\r\n  0x13c: '        ACCESS CODE:',\r\n  0x13d: 'PRESS BUTTON OR RETURN TO CONTINUE',\r\n  0x13e: '   ENTER ACCESS CODE',\r\n  0x13f: '   INVALID PASSWORD !',\r\n  0x140: 'ANNULER',\r\n  0x141: '      INSERT DISK ?\\n\\n\\n\\n\\n\\n\\n\\n\\nPRESS ANY KEY TO CONTINUE',\r\n  0x142: ' SELECT SYMBOLS CORRESPONDING TO\\n THE POSITION\\n ON THE CODE WHEEL',\r\n  0x143: '    LOADING...',\r\n  0x144: '              ERROR',\r\n  0x15e: 'LDKD',\r\n  0x15f: 'HTDC',\r\n  0x160: 'CLLD',\r\n  0x161: 'FXLC',\r\n  0x162: 'KRFK',\r\n  0x163: 'XDDJ',\r\n  0x164: 'LBKG',\r\n  0x165: 'KLFB',\r\n  0x166: 'TTCT',\r\n  0x167: 'DDRX',\r\n  0x168: 'TBHK',\r\n  0x169: 'BRTD',\r\n  0x16a: 'CKJL',\r\n  0x16b: 'LFCK',\r\n  0x16c: 'BFLX',\r\n  0x16d: 'XJRT',\r\n  0x16e: 'HRTB',\r\n  0x16f: 'HBHK',\r\n  0x170: 'JCGB',\r\n  0x171: 'HHFL',\r\n  0x172: 'TFBB',\r\n  0x173: 'TXHF',\r\n  0x174: 'JHJL',\r\n  0x181: ' BY',\r\n  0x182: 'ERIC CHAHI',\r\n  0x183: '         MUSIC AND SOUND EFFECTS',\r\n  0x184: ' ',\r\n  0x185: 'JEAN-FRANCOIS FREITAS',\r\n  0x186: 'IBM PC VERSION',\r\n  0x187: '      BY',\r\n  0x188: ' DANIEL MORAIS',\r\n  0x18b: '       THEN PRESS FIRE',\r\n  0x18c: ' PUT THE PADDLE ON THE UPPER LEFT CORNER',\r\n  0x18d: 'PUT THE PADDLE IN CENTRAL POSITION',\r\n  0x18e: 'PUT THE PADDLE ON THE LOWER RIGHT CORNER',\r\n  0x190: 'Good evening professor.',\r\n  0x191: 'I see you have driven here in your\\nFerrari.',\r\n  0x192: 'IDENTIFICATION',\r\n  0x193: 'AU BOULOT !!!\\n',\r\n  0x194: 'Y\\n',\r\n  0x1f4: 'Over Two Years in the Making',\r\n  0x1f5: '   A New, State\\nof the Art, Polygon\\n  Graphics System',\r\n  0x1f6: '   Comes to the\\nComputer With Full\\n Screen Graphics',\r\n  0x1f7:\r\n    'While conducting a nuclear fission\\nexperiment at your local\\nparticle accelerator ...',\r\n  0x1f8: 'Nature decides to put a little\\n    extra spin on the ball',\r\n  0x1f9: 'And sends you ...',\r\n  0x1fa:\r\n    '     Out of this World\\nA Cinematic Action Adventure\\n from Interplay Productions\\n                    \\n       By Eric CHAHI      \\n\\n  IBM version : D.MORAIS\\n',\r\n  0x258: '      Designed by ..... Eric Chahi',\r\n  0x259: '    Programmed by...... Eric Chahi',\r\n  0x25a: '      Artwork ......... Eric Chahi',\r\n  0x25b: 'Music by ........ Jean-francois Freitas',\r\n  0x25c: '            Sound effects',\r\n  0x25d: '        Jean-Francois Freitas\\n             Eric Chahi',\r\n  0x263: '              Thanks To',\r\n  0x264:\r\n    '           Jesus Martinez\\n\\n          Daniel Morais\\n\\n        Frederic Savoir\\n\\n      Cecile Chahi\\n\\n    Philippe Delamarre\\n\\n  Philippe Ulrich\\n\\nSebastien Berthet\\n\\nPierre Gousseau',\r\n  0x265: 'Now Go Out Of This World',\r\n};\r\n\r\nexport const strings_fr = {\r\n  0x022: '--- Etude theorique ---',\r\n  0x023: \" L'EXPERIENCE DEBUTERA DANS    SECONDES.\",\r\n  0x024: '20',\r\n  0x025: '19',\r\n  0x026: '18',\r\n  0x027: '4',\r\n  0x028: '3',\r\n  0x029: '2',\r\n  0x02a: '1',\r\n  0x02b: '0',\r\n  0x031: '- Phase 0:\\nINJECTION des particules\\ndans le synchrotron',\r\n  0x032: '- Phase 1:\\nACCELERATION des particules.',\r\n  0x033: '- Phase 2:\\nEJECTION des particules\\nsur le bouclier.',\r\n  0x034: 'A  N  A  L  Y  S  E',\r\n  0x035:\r\n    '- RESULTAT:\\nProbabilites de creer de:\\n ANTI-MATIERE: 91.V %\\n NEUTRINO 27:  0.04 %\\n NEUTRINO 424: 18 %\\n',\r\n  0x036: 'Verification par la pratique O/N ?',\r\n  0x037: 'SUR ?',\r\n  0x038:\r\n    \"MODIFICATION DES PARAMETRES\\nRELATIFS A L'ACCELERATEUR\\nDE PARTICULES (SYNCHROTRON).\",\r\n  0x039: \"SIMULATION DE L'EXPERIENCE ?\",\r\n  0x04b: '5',\r\n  0x04c: '17',\r\n  0x13c: \"       CODE D'ACCES:\",\r\n  0x13d: 'PRESSEZ LE BOUTON POUR CONTINUER',\r\n  0x13e: \"   ENTRER LE CODE D'ACCES\",\r\n  0x13f: 'MOT DE PASSE INVALIDE !',\r\n  0x141:\r\n    '     INSEREZ LA DISQUETTE ?\\n\\n\\n\\n\\n\\n\\n\\n\\nPRESSEZ UNE TOUCHE POUR CONTINUER',\r\n  0x142:\r\n    'SELECTIONNER LES SYMBOLES CORRESPONDANTS\\nA LA POSITION\\nDE LA ROUE DE PROTECTION',\r\n  0x143: 'CHARGEMENT...',\r\n  0x144: '             ERREUR',\r\n  0x181: 'PAR',\r\n  0x183: '          MUSIQUES ET BRUITAGES',\r\n  0x184: 'DE',\r\n  0x186: 'VERSION IBM PC',\r\n  0x187: '      PAR',\r\n  0x18b: 'PUIS PRESSER LE BOUTON',\r\n  0x18c: 'POSITIONNER LE JOYSTICK EN HAUT A GAUCHE',\r\n  0x18d: ' POSITIONNER LE JOYSTICK AU CENTRE',\r\n  0x18e: ' POSITIONNER LE JOYSTICK EN BAS A DROITE',\r\n  0x190: 'Bonsoir professeur.',\r\n  0x191: 'Je vois que Monsieur a pris\\nsa Ferrari.',\r\n  0x194: 'O',\r\n  0x258: '       Conception ..... Eric Chahi',\r\n  0x259: '    Programmation ..... Eric Chahi',\r\n  0x25a: '     Graphismes ....... Eric Chahi',\r\n  0x25b: 'Musique de ...... Jean-francois Freitas',\r\n  0x25c: '              Bruitages',\r\n  0x263: '               Merci a',\r\n  0x265: 'Now Go Back To Another Earth',\r\n};\r\n\r\nexport const font = [\r\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10,\r\n  0x00, 0x10, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24,\r\n  0x7e, 0x24, 0x24, 0x7e, 0x24, 0x00, 0x08, 0x3e, 0x48, 0x3c, 0x12, 0x7c, 0x10,\r\n  0x00, 0x42, 0xa4, 0x48, 0x10, 0x24, 0x4a, 0x84, 0x00, 0x60, 0x90, 0x90, 0x70,\r\n  0x8a, 0x84, 0x7a, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,\r\n  0x08, 0x10, 0x10, 0x10, 0x08, 0x06, 0x00, 0xc0, 0x20, 0x10, 0x10, 0x10, 0x20,\r\n  0xc0, 0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x10, 0x10,\r\n  0x7c, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20,\r\n  0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\r\n  0x28, 0x10, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x78, 0x84,\r\n  0x8c, 0x94, 0xa4, 0xc4, 0x78, 0x00, 0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x7c,\r\n  0x00, 0x78, 0x84, 0x04, 0x08, 0x30, 0x40, 0xfc, 0x00, 0x78, 0x84, 0x04, 0x38,\r\n  0x04, 0x84, 0x78, 0x00, 0x08, 0x18, 0x28, 0x48, 0xfc, 0x08, 0x08, 0x00, 0xfc,\r\n  0x80, 0xf8, 0x04, 0x04, 0x84, 0x78, 0x00, 0x38, 0x40, 0x80, 0xf8, 0x84, 0x84,\r\n  0x78, 0x00, 0xfc, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x78, 0x84, 0x84,\r\n  0x78, 0x84, 0x84, 0x78, 0x00, 0x78, 0x84, 0x84, 0x7c, 0x04, 0x08, 0x70, 0x00,\r\n  0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,\r\n  0x10, 0x10, 0x60, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00,\r\n  0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20,\r\n  0x00, 0x7c, 0x82, 0x02, 0x0c, 0x10, 0x00, 0x10, 0x00, 0x30, 0x18, 0x0c, 0x0c,\r\n  0x0c, 0x18, 0x30, 0x00, 0x78, 0x84, 0x84, 0xfc, 0x84, 0x84, 0x84, 0x00, 0xf8,\r\n  0x84, 0x84, 0xf8, 0x84, 0x84, 0xf8, 0x00, 0x78, 0x84, 0x80, 0x80, 0x80, 0x84,\r\n  0x78, 0x00, 0xf8, 0x84, 0x84, 0x84, 0x84, 0x84, 0xf8, 0x00, 0x7c, 0x40, 0x40,\r\n  0x78, 0x40, 0x40, 0x7c, 0x00, 0xfc, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80, 0x00,\r\n  0x7c, 0x80, 0x80, 0x8c, 0x84, 0x84, 0x7c, 0x00, 0x84, 0x84, 0x84, 0xfc, 0x84,\r\n  0x84, 0x84, 0x00, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x00, 0x04, 0x04,\r\n  0x04, 0x04, 0x84, 0x84, 0x78, 0x00, 0x8c, 0x90, 0xa0, 0xe0, 0x90, 0x88, 0x84,\r\n  0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x00, 0x82, 0xc6, 0xaa, 0x92,\r\n  0x82, 0x82, 0x82, 0x00, 0x84, 0xc4, 0xa4, 0x94, 0x8c, 0x84, 0x84, 0x00, 0x78,\r\n  0x84, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0xf8, 0x84, 0x84, 0xf8, 0x80, 0x80,\r\n  0x80, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x8c, 0x7c, 0x03, 0xf8, 0x84, 0x84,\r\n  0xf8, 0x90, 0x88, 0x84, 0x00, 0x78, 0x84, 0x80, 0x78, 0x04, 0x84, 0x78, 0x00,\r\n  0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84,\r\n  0x84, 0x78, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84, 0x48, 0x30, 0x00, 0x82, 0x82,\r\n  0x82, 0x82, 0x92, 0xaa, 0xc6, 0x00, 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82,\r\n  0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0xfc, 0x04, 0x08, 0x10,\r\n  0x20, 0x40, 0xfc, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x3c,\r\n  0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30,\r\n  0x3c, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 0x00, 0x00,\r\n  0x00, 0x00, 0x00, 0x00, 0xfe, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00,\r\n  0x00, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3c, 0x00, 0x40, 0x40, 0x78, 0x44, 0x44,\r\n  0x44, 0x78, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x40, 0x40, 0x3c, 0x00, 0x04, 0x04,\r\n  0x3c, 0x44, 0x44, 0x44, 0x3c, 0x00, 0x00, 0x00, 0x38, 0x44, 0x7c, 0x40, 0x3c,\r\n  0x00, 0x38, 0x44, 0x40, 0x60, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x44,\r\n  0x44, 0x3c, 0x04, 0x78, 0x40, 0x40, 0x58, 0x64, 0x44, 0x44, 0x44, 0x00, 0x10,\r\n  0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02,\r\n  0x42, 0x3c, 0x40, 0x40, 0x46, 0x48, 0x70, 0x48, 0x46, 0x00, 0x10, 0x10, 0x10,\r\n  0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0xec, 0x92, 0x92, 0x92, 0x92, 0x00,\r\n  0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44,\r\n  0x44, 0x38, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x00, 0x00,\r\n  0x3c, 0x44, 0x44, 0x3c, 0x04, 0x04, 0x00, 0x00, 0x4c, 0x70, 0x40, 0x40, 0x40,\r\n  0x00, 0x00, 0x00, 0x3c, 0x40, 0x38, 0x04, 0x78, 0x00, 0x10, 0x10, 0x3c, 0x10,\r\n  0x10, 0x10, 0x0c, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00,\r\n  0x00, 0x44, 0x44, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00, 0x82, 0x82, 0x92, 0xaa,\r\n  0xc6, 0x00, 0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x42,\r\n  0x22, 0x24, 0x18, 0x08, 0x30, 0x00, 0x00, 0x7c, 0x08, 0x10, 0x20, 0x7c, 0x00,\r\n  0x60, 0x90, 0x20, 0x40, 0xf0, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,\r\n  0xfe, 0xfe, 0x00, 0x38, 0x44, 0xba, 0xa2, 0xba, 0x44, 0x38, 0x00, 0x38, 0x44,\r\n  0x82, 0x82, 0x44, 0x28, 0xee, 0x00, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,\r\n  0xaa,\r\n];\r\n","import { decompressSync } from 'fflate';\r\n\r\nexport * from './strings';\r\n\r\ntype Resource = Record<number, [string, number]>;\r\n\r\ninterface Data {\r\n  bitmaps: Resource;\r\n  sounds?: Resource;\r\n  modules?: Resource;\r\n}\r\n\r\ninterface Parts {\r\n  [key: number]: [\r\n    string,\r\n    number,\r\n    string,\r\n    number,\r\n    string,\r\n    number,\r\n    string | null,\r\n    number | null\r\n  ];\r\n}\r\n\r\nlet isDemo = true;\r\nlet partsList!: Parts;\r\nlet DATA!: Data;\r\n\r\nexport const enum GAME_PART {\r\n  PROTECTION = 0x3e80, // Code-wheel screen\r\n  INTRODUCTION = 0x3e81, // Intro Sequence\r\n  WATER = 0x3e82, // Arrival at the Lake & Beast Chase\r\n  JAIL = 0x3e83, // Prison Escape\r\n  CITY = 0x3e84, // Gas tunnels, Caves and Pool\r\n  ARENA = 0x3e85, // Tank in the Battle Arena\r\n  BATHS = 0x3e86, // Capsule Lands at the Bath\r\n  FINAL = 0x3e87, // Game Ending Sequence\r\n  CODE = 0x3e88, // Secret Code Entry Screen\r\n  CODE2 = 0x3e89, // Secret Code Entry Screen\r\n}\r\n\r\nconst FULL = 'ootw';\r\nconst DEMO = 'ootw-demo';\r\n\r\n(async function load() {\r\n  try {\r\n    /* @ts-ignore */\r\n    const RES = await import(/* @vite-ignore */ `../../../data/${FULL}.js`);\r\n\r\n    console.log('loaded ootw.js');\r\n\r\n    // const RES15 = await import(/* webpackIgnore: true */ \"../../../data/ootw-15th.js\");\r\n    // const RES = RES0;\r\n\r\n    isDemo = false;\r\n\r\n    partsList = {\r\n      [GAME_PART.PROTECTION]: [\r\n        RES.data14,\r\n        RES.size14,\r\n        RES.data15,\r\n        RES.size15,\r\n        RES.data16,\r\n        RES.size16,\r\n        null,\r\n        null,\r\n      ],\r\n      [GAME_PART.INTRODUCTION]: [\r\n        RES.data17,\r\n        RES.size17,\r\n        RES.data18,\r\n        RES.size18,\r\n        RES.data19,\r\n        RES.size19,\r\n        null,\r\n        null,\r\n      ],\r\n      [GAME_PART.WATER]: [\r\n        RES.data1a,\r\n        RES.size1a,\r\n        RES.data1b,\r\n        RES.size1b,\r\n        RES.data1c,\r\n        RES.size1c,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n      [GAME_PART.JAIL]: [\r\n        RES.data1d,\r\n        RES.size1d,\r\n        RES.data1e,\r\n        RES.size1e,\r\n        RES.data1f,\r\n        RES.size1f,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n      [GAME_PART.CITY]: [\r\n        RES.data20,\r\n        RES.size20,\r\n        RES.data21,\r\n        RES.size21,\r\n        RES.data22,\r\n        RES.size22,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n      [GAME_PART.ARENA]: [\r\n        RES.data23,\r\n        RES.size23,\r\n        RES.data24,\r\n        RES.size24,\r\n        RES.data25,\r\n        RES.size25,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n      [GAME_PART.BATHS]: [\r\n        RES.data26,\r\n        RES.size26,\r\n        RES.data27,\r\n        RES.size27,\r\n        RES.data28,\r\n        RES.size28,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n      [GAME_PART.FINAL]: [\r\n        RES.data29,\r\n        RES.size29,\r\n        RES.data2a,\r\n        RES.size2a,\r\n        RES.data2b,\r\n        RES.size2b,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n      [GAME_PART.CODE]: [\r\n        RES.data7d,\r\n        RES.size7d,\r\n        RES.data7e,\r\n        RES.size7e,\r\n        RES.data7f,\r\n        RES.size7f,\r\n        null,\r\n        null,\r\n      ],\r\n      [GAME_PART.CODE2]: [\r\n        RES.data7d,\r\n        RES.size7d,\r\n        RES.data7e,\r\n        RES.size7e,\r\n        RES.data7f,\r\n        RES.size7f,\r\n        null,\r\n        null,\r\n      ],\r\n    };\r\n\r\n    DATA = {\r\n      bitmaps: RES.bitmaps as unknown as Resource,\r\n      sounds: RES.sounds as unknown as Resource,\r\n      modules: RES.modules as unknown as Resource,\r\n    };\r\n  } catch (e) {\r\n    /* @ts-ignore */\r\n    const RES = await import(/* @vite-ignore */ `./data/${DEMO}.js`);\r\n\r\n    console.log('loaded ootw-demo.js');\r\n\r\n    partsList = {\r\n      [GAME_PART.INTRODUCTION]: [\r\n        RES.data17,\r\n        RES.size17,\r\n        RES.data18,\r\n        RES.size18,\r\n        RES.data19,\r\n        RES.size19,\r\n        null,\r\n        null,\r\n      ],\r\n      [GAME_PART.WATER]: [\r\n        RES.data1a,\r\n        RES.size1a,\r\n        RES.data1b,\r\n        RES.size1b,\r\n        RES.data1c,\r\n        RES.size1c,\r\n        RES.data11,\r\n        RES.size11,\r\n      ],\r\n    };\r\n\r\n    DATA = {\r\n      bitmaps: RES.bitmaps as unknown as Resource,\r\n      sounds: RES.sounds as unknown as Resource,\r\n      modules: RES.modules as unknown as Resource,\r\n    };\r\n  }\r\n})();\r\n\r\nexport function load_modules() {\r\n  if (!DATA?.modules) return false;\r\n\r\n  Object.entries(DATA.modules).forEach(([, module]: any[]) => {\r\n    const [data, size] = module;\r\n    module.push(load(data, size));\r\n  });\r\n\r\n  return true;\r\n}\r\n\r\nexport function load_sounds() {\r\n  if (!DATA?.sounds) return false;\r\n\r\n  Object.entries(DATA.sounds).forEach(([, sound]: any[]) => {\r\n    const [data, size] = sound;\r\n    sound.push(load(data, size));\r\n  });\r\n\r\n  return true;\r\n}\r\n\r\nexport function load(data: string | null, size: number | null) {\r\n  if (!data) return null;\r\n\r\n  data = atob(data);\r\n  if (data.length != size) {\r\n    let len = data.length;\r\n    let bytes = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n      bytes[i] = data.charCodeAt(i);\r\n    }\r\n    let buf = decompressSync(bytes);\r\n    console.assert(buf.length == size);\r\n    return buf;\r\n  }\r\n\r\n  let buf = new Uint8Array(size);\r\n  for (let i = 0; i < data.length; ++i) {\r\n    buf[i] = data.charCodeAt(i) & 0xff;\r\n  }\r\n  return buf;\r\n}\r\n\r\nexport { isDemo, partsList, DATA };\r\n","export const enum PALETTE_TYPE {\r\n  AMIGA = 0,\r\n  EGA = 1,\r\n  VGA = 2,\r\n}\r\n\r\nexport const PALETTE_EGA = [\r\n  0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x00, 0xaa, 0x00, 0x00, 0xaa, 0xaa, 0xaa,\r\n  0x00, 0x00, 0xaa, 0x00, 0xaa, 0xaa, 0x55, 0x00, 0xaa, 0xaa, 0xaa, 0x55, 0x55,\r\n  0x55, 0x55, 0x55, 0xff, 0x55, 0xff, 0x55, 0x55, 0xff, 0xff, 0xff, 0x55, 0x55,\r\n  0xff, 0x55, 0xff, 0xff, 0xff, 0x55, 0xff, 0xff, 0xff,\r\n];\r\n\r\nexport let palette_bmp = new Uint32Array(256 * 3); // 15th edition backgrounds\r\nexport let palette32 = new Uint32Array(16 * 3); // Amiga, EGA, VGA\r\nexport let palette: Uint8Array;\r\nexport let palette_type = PALETTE_TYPE.AMIGA;\r\n\r\nexport function set_palette_type(num: number) {\r\n  palette_type = num;\r\n}\r\n\r\nexport function set_palette32(data: Uint32Array) {\r\n  palette32 = data;\r\n}\r\n\r\nexport function set_palette(data: Uint8Array) {\r\n  palette = data;\r\n}\r\n\r\nexport function set_palette_ega(offset: number) {\r\n  for (let i = 0; i < 16; ++i) {\r\n    let color = (palette[offset + i * 2] << 8) | palette[offset + i * 2 + 1];\r\n    color = ((color >> 12) & 15) * 3;\r\n    palette32[PALETTE_TYPE.EGA * 16 + i] =\r\n      0xff000000 |\r\n      (PALETTE_EGA[color + 2] << 16) |\r\n      (PALETTE_EGA[color + 1] << 8) |\r\n      PALETTE_EGA[color];\r\n  }\r\n}\r\n\r\nexport function set_palette_444(offset: number, type: number) {\r\n  for (let i = 0; i < 16; ++i) {\r\n    const color = (palette[offset + i * 2] << 8) | palette[offset + i * 2 + 1];\r\n    let r = (color >> 8) & 15;\r\n    r = (r << 4) | r;\r\n    let g = (color >> 4) & 15;\r\n    g = (g << 4) | g;\r\n    let b = color & 15;\r\n    b = (b << 4) | b;\r\n    palette32[type * 16 + i] = 0xff000000 | (b << 16) | (g << 8) | r;\r\n  }\r\n}\r\n\r\nexport function set_palette_bmp(data: Uint8Array) {\r\n  let color = 0;\r\n  for (let i = 0; i < 256; ++i) {\r\n    palette_bmp[i] =\r\n      0xff000000 |\r\n      (data[color + 2] << 16) |\r\n      (data[color + 1] << 8) |\r\n      data[color];\r\n    color += 3;\r\n  }\r\n}\r\n","import * as palette from './palette';\r\n\r\nlet SCALE = 2;\r\nlet SCREEN_W = 320 * 2;\r\nlet SCREEN_H = 200 * 2;\r\nlet is_1991 = false;\r\n\r\nlet _canvas: HTMLCanvasElement;\r\n\r\nexport function update(buffer: Uint8Array, offset: number) {\r\n  let context = _canvas.getContext('2d')!;\r\n  let data = context.getImageData(0, 0, SCREEN_W, SCREEN_H);\r\n  let rgba = new Uint32Array(data.data.buffer);\r\n  if (is_1991) {\r\n    let rgba_offset = 0;\r\n    for (let y = 0; y < SCREEN_H; y += SCALE) {\r\n      for (let x = 0; x < SCREEN_W; x += SCALE) {\r\n        const color =\r\n          palette.palette32[palette.palette_type * 16 + buffer[offset + x]];\r\n        for (let j = 0; j < SCALE; ++j) {\r\n          rgba.fill(\r\n            color,\r\n            rgba_offset + j * SCREEN_W + x,\r\n            rgba_offset + j * SCREEN_W + x + SCALE\r\n          );\r\n        }\r\n      }\r\n      rgba_offset += SCREEN_W * SCALE;\r\n      offset += SCREEN_W * SCALE;\r\n    }\r\n  } else {\r\n    for (let i = 0; i < SCREEN_W * SCREEN_H; ++i) {\r\n      const color = buffer[offset + i];\r\n      if (color < 16) {\r\n        rgba[i] = palette.palette32[palette.palette_type * 16 + color];\r\n      } else {\r\n        rgba[i] = palette.palette_bmp[color - 16];\r\n      }\r\n    }\r\n  }\r\n  context.putImageData(data, 0, 0);\r\n}\r\n\r\nexport function init(\r\n  canvas: HTMLCanvasElement,\r\n  W: number,\r\n  H: number,\r\n  S: number\r\n) {\r\n  _canvas = canvas;\r\n\r\n  SCALE = S;\r\n  SCREEN_W = W;\r\n  SCREEN_H = H;\r\n}\r\n\r\nexport function set_resolution(low: boolean) {\r\n  is_1991 = low;\r\n}\r\n\r\nexport function toggle_resolution() {\r\n  is_1991 = !is_1991;\r\n}\r\n","export const enum VAR {\r\n  RANDOM_SEED = 0x3c,\r\n  LAST_KEYCHAR = 0xda,\r\n  HERO_POS_UP_DOWN = 0xe5,\r\n  SCROLL_Y = 0xf9,\r\n  HERO_ACTION = 0xfa,\r\n  HERO_POS_JUMP_DOWN = 0xfb,\r\n  HERO_POS_LEFT_RIGHT = 0xfc,\r\n  HERO_POS_MASK = 0xfd,\r\n  HERO_ACTION_POS_MASK = 0xfe,\r\n  PAUSE_SLICES = 0xff,\r\n  MUSIC_SYNC = 0xf4,\r\n  WTF = 0xf7,\r\n  HACK_VAR_54 = 0x54,\r\n  HACK_VAR_67 = 0x67,\r\n  HACK_VAR_DC = 0xdc,\r\n  HACK_VAR_F7 = 0xf7,\r\n  HACK_VAR_BC = 0xbc,\r\n  HACK_VAR_F2 = 0xf2,\r\n  HACK_VAR_C6 = 0xc6,\r\n  HACK_VAR_E4 = 0xe4,\r\n}\r\n\r\nexport interface TaskState {\r\n  state: number;\r\n  next_state: number;\r\n  offset: number;\r\n  next_offset: number;\r\n  stack: number[];\r\n}\r\n\r\nexport const vmVars: number[] = new Array(256);\r\nexport const vmTasks: TaskState[] = new Array(64);\r\n","import * as memory from './memory';\r\n\r\nimport { VAR } from './memory';\r\n\r\nexport const enum KEY_CODE {\r\n  UP = 1,\r\n  RIGHT = 2,\r\n  DOWN = 3,\r\n  LEFT = 4,\r\n  ACTION = 5,\r\n  JUMP = 6,\r\n  FF = 7,\r\n}\r\n\r\nlet gamepadState = new Array(6);\r\nlet keyboardState = new Array(6);\r\n\r\nexport function buttonPressed(b: any) {\r\n  if (typeof b === 'object') {\r\n    return b.pressed;\r\n  }\r\n  return b === 1.0;\r\n}\r\n\r\nexport function pollGamepads() {\r\n  const gamepads = navigator.getGamepads();\r\n  if (!gamepads) {\r\n    return;\r\n  }\r\n\r\n  const gamepad = gamepads[0];\r\n\r\n  if (gamepad) {\r\n    gamepadState[KEY_CODE.UP] = gamepad.axes[1] < -0.5;\r\n    gamepadState[KEY_CODE.DOWN] = gamepad.axes[1] > 0.5;\r\n    gamepadState[KEY_CODE.LEFT] = gamepad.axes[0] < -0.5;\r\n    gamepadState[KEY_CODE.RIGHT] = gamepad.axes[0] > 0.5;\r\n\r\n    gamepadState[KEY_CODE.JUMP] = buttonPressed(gamepad.buttons[1]);\r\n    gamepadState[KEY_CODE.ACTION] = buttonPressed(gamepad.buttons[0]);\r\n\r\n    gamepadState[KEY_CODE.FF] =\r\n      buttonPressed(gamepad.buttons[5]) || buttonPressed(gamepad.buttons[7]);\r\n  }\r\n}\r\n\r\nexport function is_key_pressed(code: number) {\r\n  return keyboardState[code] || gamepadState[code];\r\n}\r\n\r\nconst controls = {\r\n  ' ': KEY_CODE.ACTION,\r\n  'Enter': KEY_CODE.ACTION,\r\n  'Shift': KEY_CODE.JUMP,\r\n  'ArrowUp': KEY_CODE.UP,\r\n  'ArrowDown': KEY_CODE.DOWN,\r\n  'ArrowLeft': KEY_CODE.LEFT,\r\n  'ArrowRight': KEY_CODE.RIGHT,\r\n  'f': KEY_CODE.FF,\r\n};\r\n\r\nfunction set_key_pressed(e: KeyboardEvent, state: unknown) {\r\n  if (e.key in controls) {\r\n    e.preventDefault();\r\n    const code: KEY_CODE = controls[e.key as keyof typeof controls];\r\n    keyboardState[code] = state;\r\n  }\r\n}\r\n\r\nexport function bind_events() {\r\n  document.onkeydown = function (e) {\r\n    set_key_pressed(e, 1);\r\n  };\r\n  document.onkeyup = function (e) {\r\n    set_key_pressed(e, 0);\r\n  };\r\n}\r\n\r\nexport function update_input() {\r\n  let mask = 0;\r\n\r\n  memory.vmVars[VAR.HERO_POS_LEFT_RIGHT] = 0;\r\n  memory.vmVars[VAR.HERO_POS_JUMP_DOWN] = 0;\r\n  memory.vmVars[VAR.HERO_POS_UP_DOWN] = 0;\r\n  memory.vmVars[VAR.HERO_ACTION] = 0;\r\n\r\n  if (is_key_pressed(KEY_CODE.RIGHT)) {\r\n    memory.vmVars[VAR.HERO_POS_LEFT_RIGHT] = 1;\r\n    mask |= 1;\r\n  } else if (is_key_pressed(KEY_CODE.LEFT)) {\r\n    memory.vmVars[VAR.HERO_POS_LEFT_RIGHT] = -1;\r\n    mask |= 2;\r\n  }\r\n\r\n  if (is_key_pressed(KEY_CODE.DOWN)) {\r\n    memory.vmVars[VAR.HERO_POS_UP_DOWN] = 1;\r\n    mask |= 4;\r\n  } else if (is_key_pressed(KEY_CODE.UP)) {\r\n    memory.vmVars[VAR.HERO_POS_UP_DOWN] = -1;\r\n    mask |= 8;\r\n  }\r\n\r\n  if (is_key_pressed(KEY_CODE.JUMP)) {\r\n    memory.vmVars[VAR.HERO_POS_JUMP_DOWN] = -1;\r\n    mask |= 8;\r\n  }\r\n\r\n  memory.vmVars[VAR.HERO_POS_MASK] = mask;\r\n\r\n  if (is_key_pressed(KEY_CODE.ACTION)) {\r\n    memory.vmVars[VAR.HERO_ACTION] = 1;\r\n    mask |= 0x80;\r\n  }\r\n\r\n  memory.vmVars[VAR.HERO_ACTION_POS_MASK] = mask;\r\n}\r\n","!function(){var e,t=[];function r(e){var r=this,n={},i=-1;this.parameters.forEach(function(e,o){var a=t[++i]||(t[i]=new Float32Array(r.bufferSize));a.fill(e.value),n[o]=a}),this.processor.realm.exec(\"self.sampleRate=sampleRate=\"+this.context.sampleRate+\";self.currentTime=currentTime=\"+this.context.currentTime);var a=o(e.inputBuffer),s=o(e.outputBuffer);this.instance.process([a],[s],n)}function o(e){for(var t=[],r=0;r<e.numberOfChannels;r++)t[r]=e.getChannelData(r);return t}function n(e){return e.$$processors||(e.$$processors={})}\"function\"==typeof AudioWorkletNode&&\"audioWorklet\"in AudioContext.prototype||(self.AudioWorkletNode=function(t,o,i){var a=n(t)[o],s=t.createScriptProcessor(void 0,2,i&&i.outputChannelCount?i.outputChannelCount[0]:2);if(s.parameters=new Map,a.properties)for(var u=0;u<a.properties.length;u++){var c=a.properties[u],l=t.createGain().gain;l.value=c.defaultValue,s.parameters.set(c.name,l)}var p=new MessageChannel;e=p.port2;var f=new a.Processor(i||{});return e=null,s.port=p.port1,s.processor=a,s.instance=f,s.onaudioprocess=r,s},Object.defineProperty((self.AudioContext||self.webkitAudioContext).prototype,\"audioWorklet\",{get:function(){return this.$$audioWorklet||(this.$$audioWorklet=new self.AudioWorklet(this))}}),self.AudioWorklet=function(){function t(e){this.$$context=e}return t.prototype.addModule=function(t,r){var o=this;return fetch(t).then(function(e){if(!e.ok)throw Error(e.status);return e.text()}).then(function(t){var i={sampleRate:o.$$context.sampleRate,currentTime:o.$$context.currentTime,AudioWorkletProcessor:function(){this.port=e},registerProcessor:function(e,t){n(o.$$context)[e]={realm:a,context:i,Processor:t,properties:t.parameterDescriptors||[]}}};i.self=i;var a=new function(e,t){var r=document.createElement(\"iframe\");r.style.cssText=\"position:absolute;left:0;top:-999px;width:1px;height:1px;\",t.appendChild(r);var o=r.contentWindow,n=o.document,i=\"var window,$hook\";for(var a in o)a in e||\"eval\"===a||(i+=\",\",i+=a);for(var s in e)i+=\",\",i+=s,i+=\"=self.\",i+=s;var u=n.createElement(\"script\");u.appendChild(n.createTextNode('function $hook(self,console) {\"use strict\";\\n        '+i+\";return function() {return eval(arguments[0])}}\")),n.body.appendChild(u),this.exec=o.$hook.call(e,e,console)}(i,document.documentElement);return a.exec((r&&r.transpile||String)(t)),null})},t}())}();\n//# sourceMappingURL=audioworklet-polyfill.js.map\n","import '@free-side/audioworklet-polyfill';\r\n\r\nconst CreateSfxMod = () => ({\r\n  orderTable: new Array(0x80),\r\n  curOrder: 0,\r\n  numOrder: 0,\r\n  curPos: 0,\r\n  data: null as any as Uint8Array,\r\n  samples: new Array(15).fill(null).map(() => ({\r\n    data: null,\r\n    volume: 0,\r\n  })),\r\n});\r\n\r\nconst createSfx = () =>\r\n  ({\r\n    sample: null as any,\r\n    volume: 0,\r\n    loops: 0,\r\n    loop: 0,\r\n  } as any);\r\n\r\nfunction read_be_uint16(buf: Uint8Array, offset: number) {\r\n  return (buf[offset] << 8) | buf[offset + 1];\r\n}\r\n\r\nexport class SfxPlayer {\r\n  _delay = 0;\r\n  _resNum = 0;\r\n  _sfxMod = CreateSfxMod();\r\n  _rate: number | undefined = 0;\r\n  _channels = new Array(4).fill(null);\r\n\r\n  // new\r\n  _audioContext!: AudioContext;\r\n  _sfxRawWorklet!: AudioWorkletNode;\r\n  _sfxPlayerWorklet!: AudioWorkletNode;\r\n  _modifyVarCallback: any = null;\r\n\r\n  constructor() {\r\n    // console.log('SfxPlayer::constructor')\r\n    this._audioContext = new window.AudioContext();\r\n    this.resumeAudio();\r\n  }\r\n\r\n  setModifyVarCallback(modifyVarCallback: any) {\r\n    this._modifyVarCallback = modifyVarCallback;\r\n  }\r\n\r\n  async init() {\r\n    // console.log('SfxPlayer::init')\r\n    await this.initAudio();\r\n    this.initEvents();\r\n  }\r\n\r\n  async initAudio() {\r\n    try {\r\n      // console.log('SfxPlayer::initAudio')\r\n      this._rate = this._audioContext.sampleRate;\r\n\r\n      // console.log('Adding module processors')\r\n      await this._audioContext.audioWorklet.addModule('assets/processors.js');\r\n\r\n      // console.log('Creating worklet raw')\r\n      this._sfxRawWorklet = new AudioWorkletNode(\r\n        this._audioContext,\r\n        'sfxraw-processor',\r\n        {\r\n          outputChannelCount: [1],\r\n          numberOfInputs: 0,\r\n          numberOfOutputs: 1,\r\n        }\r\n      );\r\n\r\n      this._sfxRawWorklet.port.onmessage =\r\n        this.onSFXRawProcessorMessage.bind(this);\r\n      this._sfxRawWorklet.port.start();\r\n\r\n      // console.log('Creating worklet sfxplayer')\r\n      this._sfxPlayerWorklet = new AudioWorkletNode(\r\n        this._audioContext,\r\n        'sfxplayer-processor',\r\n        {\r\n          outputChannelCount: [2],\r\n          numberOfInputs: 0,\r\n          numberOfOutputs: 1,\r\n        }\r\n      );\r\n      this._sfxPlayerWorklet.port.onmessage =\r\n        this.onSFXPlayerProcessorMessage.bind(this);\r\n      this._sfxPlayerWorklet.port.start();\r\n\r\n      this._sfxRawWorklet.connect(this._audioContext.destination);\r\n      this._sfxPlayerWorklet.connect(this._audioContext.destination);\r\n\r\n      this.postMessageToSFXPlayerProcessor({\r\n        message: 'init',\r\n        mixingRate: this._rate,\r\n      });\r\n\r\n      this.postMessageToSFXRawProcessor({\r\n        message: 'init',\r\n        mixingRate: this._rate,\r\n      });\r\n    } catch (e: any) {\r\n      console.error(`Error during initAudio: ${e} ${e.stack}`);\r\n    }\r\n  }\r\n\r\n  initEvents() {\r\n    document.addEventListener('click', () => this.resumeAudio());\r\n  }\r\n\r\n  resumeAudio() {\r\n    if (this._audioContext && this._audioContext.state === 'suspended') {\r\n      this._audioContext.resume();\r\n    }\r\n  }\r\n\r\n  setEventsDelay(delay: number, shouldSend = false) {\r\n    this._delay = ((delay * 60) / 7050) >> 0;\r\n    if (shouldSend) {\r\n      this.postMessageToSFXPlayerProcessor({\r\n        message: 'setEventsDelay',\r\n        delay: this._delay,\r\n      });\r\n    }\r\n  }\r\n\r\n  onSFXPlayerProcessorMessage(event: any) {\r\n    const data = event.data;\r\n    switch (data.message) {\r\n      case 'syncVar':\r\n        const { variable, value } = data;\r\n        // vmVars[variable] = value\r\n        this._modifyVarCallback(variable, value);\r\n        break;\r\n    }\r\n  }\r\n\r\n  onSFXRawProcessorMessage(_event: any) {}\r\n\r\n  postMessageToSFXPlayerProcessor(message: any) {\r\n    if (this._sfxPlayerWorklet) {\r\n      this._sfxPlayerWorklet.port.postMessage(message);\r\n    } else {\r\n      console.warn(\r\n        'Cannot send message to sfx player processor: not available'\r\n      );\r\n    }\r\n  }\r\n\r\n  postMessageToSFXRawProcessor(message: any) {\r\n    if (this._sfxRawWorklet) {\r\n      this._sfxRawWorklet.port.postMessage(message);\r\n    } else {\r\n      console.warn(\r\n        'Cannot send message to raw player processor: not available'\r\n      );\r\n    }\r\n  }\r\n\r\n  loadSfxModule(resNum: number, delay: number, pos: number, res: any) {\r\n    const [, , buf] = res.modules[resNum];\r\n    if (buf) {\r\n      this._resNum = resNum;\r\n      this._sfxMod = CreateSfxMod();\r\n      this._sfxMod.curOrder = pos;\r\n      this._sfxMod.numOrder = read_be_uint16(buf, 0x3e);\r\n      // console.log(`SfxPlayer::loadSfxModule() curOrder = 0x${this._sfxMod.curOrder.toString(16)} numOrder = 0x${this._sfxMod.numOrder.toString(16)}`)\r\n      for (let i = 0; i < 0x80; ++i) {\r\n        this._sfxMod.orderTable[i] = buf[0x40 + i];\r\n      }\r\n\r\n      if (delay === 0) {\r\n        delay = read_be_uint16(buf, 0);\r\n      }\r\n\r\n      this.setEventsDelay(delay);\r\n      this._sfxMod.data = new Uint8Array(buf.buffer, 0xc0);\r\n      // console.log(`SfxPlayer::loadSfxModule() eventDelay = ${this._delay} ms`)\r\n      this.prepareInstruments(new Uint8Array(buf.buffer, 2), res.sounds);\r\n      this.postMessageToSFXPlayerProcessor({\r\n        message: 'load',\r\n        sfxMod: this._sfxMod,\r\n        delay: this._delay,\r\n      } as any);\r\n    } else {\r\n      debugger;\r\n    }\r\n  }\r\n\r\n  prepareInstruments(p: Uint8Array, sounds: any) {\r\n    let offset = 0;\r\n    for (let i = 0; i < 15; ++i) {\r\n      const ins = this._sfxMod.samples[i];\r\n      const resNum = read_be_uint16(p, offset);\r\n      // console.log(`prepareInstruments() resNum=${resNum}`)\r\n      offset += 2;\r\n      if (resNum !== 0) {\r\n        ins.volume = read_be_uint16(p, offset);\r\n        const mem = sounds[resNum];\r\n        if (mem && mem[2]) {\r\n          ins.data = mem[2];\r\n          // console.log(`Loaded instrument 0x${resNum.toString(16)} n=${i} volume=${ins.volume} -> [${ins.data[0].toString(16)}, ${ins.data[1].toString(16)}, ${ins.data[2].toString(16)}]`)\r\n        } else {\r\n          console.error(`Error loading instrument 0x${resNum.toString(16)}`);\r\n        }\r\n      }\r\n      offset += 2; // skip volume\r\n    }\r\n  }\r\n\r\n  startMusic() {\r\n    this.postMessageToSFXPlayerProcessor({\r\n      message: 'start',\r\n    });\r\n  }\r\n\r\n  stopMusic() {\r\n    this.postMessageToSFXPlayerProcessor({\r\n      message: 'stop',\r\n    });\r\n  }\r\n\r\n  playMusic() {\r\n    this.stopMusic();\r\n    this.postMessageToSFXPlayerProcessor({\r\n      message: 'play',\r\n      mixingRate: this._rate,\r\n    });\r\n  }\r\n\r\n  pause() {\r\n    this.postMessageToSFXRawProcessor({\r\n      message: 'pause',\r\n    });\r\n\r\n    this.postMessageToSFXPlayerProcessor({\r\n      message: 'pause',\r\n    });\r\n  }\r\n\r\n  resume() {\r\n    this.postMessageToSFXRawProcessor({\r\n      message: 'resume',\r\n    });\r\n\r\n    this.postMessageToSFXPlayerProcessor({\r\n      message: 'resume',\r\n    });\r\n  }\r\n\r\n  playSoundRaw(\r\n    channel: number,\r\n    data: Uint8Array,\r\n    freq: number,\r\n    volume: number\r\n  ) {\r\n    let len = read_be_uint16(data, 0) * 2;\r\n    const loopLen = read_be_uint16(data, 2) * 2;\r\n    if (loopLen !== 0) {\r\n      len = loopLen;\r\n    }\r\n    const sample = new Int8Array(data.buffer, 8, len || data.byteLength - 8);\r\n    // convert signed 8bit mono freq hz to host/stereo/host_freq\r\n    if (sample) {\r\n      const sfx = createSfx();\r\n      sfx.loops = loopLen !== 0 ? -1 : 0;\r\n      sfx.volume = volume;\r\n      sfx.freq = freq;\r\n      sfx.sample = sample;\r\n      this.postMessageToSFXRawProcessor({\r\n        message: 'play',\r\n        sound: sfx,\r\n        channel,\r\n      });\r\n    }\r\n  }\r\n\r\n  stopSoundChannel(channel: number) {\r\n    this.postMessageToSFXRawProcessor({\r\n      message: 'stop',\r\n      channel,\r\n    });\r\n  }\r\n}\r\n","import { DATA, load_modules, load_sounds } from '../resources';\r\nimport { SfxPlayer } from '../sound/SfxPlayer';\r\n\r\nconst freqTable = [\r\n  0x0cff, 0x0dc3, 0x0e91, 0x0f6f, 0x1056, 0x114e, 0x1259, 0x136c, 0x149f,\r\n  0x15d9, 0x1726, 0x1888, 0x19fd, 0x1b86, 0x1d21, 0x1ede, 0x20ab, 0x229c,\r\n  0x24b3, 0x26d7, 0x293f, 0x2bb2, 0x2e4c, 0x3110, 0x33fb, 0x370d, 0x3a43,\r\n  0x3ddf, 0x4157, 0x4538, 0x4998, 0x4dae, 0x5240, 0x5764, 0x5c9a, 0x61c8,\r\n  0x6793, 0x6e19, 0x7485, 0x7bbd,\r\n];\r\n\r\n// SOUNDS\r\nexport let player: SfxPlayer | null;\r\n\r\nexport async function init() {\r\n  player = new SfxPlayer();\r\n  await player.init();\r\n  if (!load_sounds()) {\r\n    console.log('error loading sounds');\r\n    player = null;\r\n  }\r\n  load_modules();\r\n}\r\n\r\nexport function play_music(resNum: number, delay: number, pos: number) {\r\n  if (player === null) return;\r\n\r\n  if (resNum !== 0) {\r\n    // _ply->loadSfxModule(resNum, delay, pos);\r\n    player.loadSfxModule(resNum, delay, pos, DATA);\r\n    player.startMusic();\r\n    player.playMusic();\r\n  } else if (delay !== 0) {\r\n    player.setEventsDelay(delay, true);\r\n  } else {\r\n    player.stopMusic();\r\n  }\r\n}\r\n\r\nexport function play_sound(\r\n  resNum: number,\r\n  freq: number,\r\n  vol: number,\r\n  channel: number\r\n) {\r\n  if (player === null) return;\r\n\r\n  if (vol === 0) {\r\n    player.stopSoundChannel(channel);\r\n    return;\r\n  }\r\n  if (vol > 63) {\r\n    vol = 63;\r\n  }\r\n  try {\r\n    if (DATA.sounds && DATA.sounds[resNum]) {\r\n      const [, , me] = DATA.sounds[resNum] as any;\r\n      if (me) {\r\n        // assert(freq < 40);\r\n        if (freq >= 40) {\r\n          console.error(`Assertion failed: $({freq} < 40`);\r\n        }\r\n        player.playSoundRaw(channel & 3, me, freqTable[freq], vol);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(`Could not play raw sound ${resNum}`);\r\n    debugger;\r\n  }\r\n}\r\n","export const enum OP_CODE {\r\n  /* 0x00 */\r\n  movConst,\r\n  mov,\r\n  add,\r\n  addConst,\r\n\r\n  /* 0x04 */\r\n  call,\r\n  ret,\r\n  pauseThread,\r\n  jmp,\r\n\r\n  /* 0x08 */\r\n  setSetVect,\r\n  jnz,\r\n  condJmp,\r\n  setPalette,\r\n\r\n  /* 0x0C */\r\n  resetThread,\r\n  selectVideoPage,\r\n  fillVideoPage,\r\n  copyVideoPage,\r\n\r\n  /* 0x10 */\r\n  blitFramebuffer,\r\n  killThread,\r\n  drawString,\r\n  sub,\r\n\r\n  /* 0x14 */\r\n  and,\r\n  or,\r\n  shl,\r\n  shr,\r\n\r\n  /* 0x18 */\r\n  playSound,\r\n  updateMemList,\r\n  playMusic,\r\n}\r\n\r\nexport const DRAW_POLY_BACKGROUND = 0x80;\r\nexport const DRAW_POLY_SPRITE = 0x40;\r\n","import {\r\n  DATA,\r\n  font,\r\n  isDemo,\r\n  load,\r\n  GAME_PART,\r\n  partsList,\r\n  strings_en,\r\n  strings_fr,\r\n  STRINGS_LANGUAGE,\r\n} from '../resources';\r\n\r\nimport * as screen from './canvas';\r\nimport * as palette from './palette';\r\nimport * as controls from './controls';\r\nimport * as sound from './sound';\r\nimport * as memory from './memory';\r\n\r\nimport { VAR } from './memory';\r\nimport type { TaskState } from './memory';\r\nimport { KEY_CODE } from './controls';\r\nimport { OP_CODE, DRAW_POLY_BACKGROUND, DRAW_POLY_SPRITE } from './opcodes';\r\n\r\nexport interface State {\r\n  part: number;\r\n  vars: number[];\r\n  tasks: TaskState[];\r\n  buffer8: Uint8Array;\r\n  palette32: Uint32Array;\r\n}\r\n\r\nconst BYPASS_PROTECTION = true;\r\n\r\nlet strings_language = STRINGS_LANGUAGE.EN;\r\n\r\nconst SCALE = 3;\r\nconst SCREEN_W = 320 * SCALE;\r\nconst SCREEN_H = 200 * SCALE;\r\nconst PAGE_SIZE = SCREEN_W * SCREEN_H;\r\n\r\nconst FPS = 50;\r\n\r\nlet buffer8 = new Uint8Array(4 * PAGE_SIZE);\r\nlet current_page0: number; // current\r\nlet current_page1: number; // front\r\nlet current_page2: number; // back\r\nlet next_palette = -1;\r\n\r\nlet bytecode: Uint8Array;\r\nlet polygons1: Uint8Array;\r\nlet polygons2: Uint8Array;\r\nlet bytecode_offset: number;\r\n\r\nlet task_num: number;\r\nlet task_paused: boolean;\r\n\r\nlet next_part: number;\r\nlet current_part = 0;\r\n\r\nlet timestamp: number;\r\n\r\nfunction read_byte(): number {\r\n  const value = bytecode[bytecode_offset];\r\n  bytecode_offset += 1;\r\n  return value;\r\n}\r\n\r\nfunction read_be_uint16(buf: any, offset: number) {\r\n  return (buf[offset] << 8) | buf[offset + 1];\r\n}\r\n\r\nfunction read_word() {\r\n  const value = read_be_uint16(bytecode, bytecode_offset);\r\n  bytecode_offset += 2;\r\n  return value;\r\n}\r\n\r\nfunction to_signed(value: number, bits: number) {\r\n  const mask = 1 << (bits - 1);\r\n  return value - ((value & mask) << 1);\r\n}\r\n\r\nfunction execute_task() {\r\n  while (!task_paused) {\r\n    const opcode = read_byte();\r\n    if (opcode & DRAW_POLY_BACKGROUND) {\r\n      // DRAW_POLY_BACKGROUND\r\n      const offset = (((opcode << 8) | read_byte()) << 1) & 0xfffe;\r\n      let x = read_byte();\r\n      let y = read_byte();\r\n      let h = y - 199;\r\n      if (h > 0) {\r\n        y = 199;\r\n        x += h;\r\n      }\r\n      draw_shape(polygons1, offset, 0xff, 64, x, y);\r\n    } else if (opcode & DRAW_POLY_SPRITE) {\r\n      // DRAW_POLY_SPRITE\r\n      const offset = (read_word() << 1) & 0xfffe;\r\n      let x = read_byte();\r\n      if ((opcode & 0x20) == 0) {\r\n        if ((opcode & 0x10) == 0) {\r\n          x = (x << 8) | read_byte();\r\n        } else {\r\n          x = memory.vmVars[x];\r\n        }\r\n      } else {\r\n        if (opcode & 0x10) {\r\n          x += 256;\r\n        }\r\n      }\r\n      let y = read_byte();\r\n      if ((opcode & 8) == 0) {\r\n        if ((opcode & 4) == 0) {\r\n          y = (y << 8) | read_byte();\r\n        } else {\r\n          y = memory.vmVars[y];\r\n        }\r\n      }\r\n      let polygons = polygons1;\r\n      let zoom = 64;\r\n      if ((opcode & 2) == 0) {\r\n        if (opcode & 1) {\r\n          zoom = memory.vmVars[read_byte()];\r\n        }\r\n      } else {\r\n        if (opcode & 1) {\r\n          polygons = polygons2;\r\n        } else {\r\n          zoom = read_byte();\r\n        }\r\n      }\r\n      draw_shape(polygons, offset, 0xff, zoom, x, y);\r\n    } else {\r\n      console.assert(opcode <= 0x1a);\r\n      if (!vm[opcode as OP_CODE]) {\r\n        console.log(`opcode ${opcode} not implemented`);\r\n      } else {\r\n        vm[opcode as OP_CODE]();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function run_tasks() {\r\n  if (next_part != 0) {\r\n    restart(next_part);\r\n    current_part = next_part;\r\n    next_part = 0;\r\n  }\r\n\r\n  for (let i = 0; i < memory.vmTasks.length; ++i) {\r\n    memory.vmTasks[i].state = memory.vmTasks[i].next_state;\r\n    const offset = memory.vmTasks[i].next_offset;\r\n    if (offset != -1) {\r\n      memory.vmTasks[i].offset = offset == -2 ? -1 : offset;\r\n      memory.vmTasks[i].next_offset = -1;\r\n    }\r\n  }\r\n\r\n  controls.pollGamepads();\r\n  controls.update_input();\r\n  // draw_text(\"Another World JS\", 20, 20, 0x0f);\r\n\r\n  for (let i = 0; i < memory.vmTasks.length; ++i) {\r\n    if (memory.vmTasks[i].state == 0) {\r\n      const offset = memory.vmTasks[i].offset;\r\n      if (offset != -1) {\r\n        bytecode_offset = offset;\r\n        memory.vmTasks[i].stack.length = 0;\r\n        task_num = i;\r\n        task_paused = false;\r\n        execute_task();\r\n        memory.vmTasks[i].offset = bytecode_offset;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction restart(part: number, pos: number = 0) {\r\n  const ResPart = partsList[part];\r\n  if (!ResPart) {\r\n    throw 'Part not found: ' + part;\r\n  }\r\n\r\n  palette.set_palette(load(ResPart[0], ResPart[1])!);\r\n  bytecode = load(ResPart[2], ResPart[3])!;\r\n  polygons1 = load(ResPart[4], ResPart[5])!;\r\n  polygons2 = load(ResPart[6], ResPart[7])!;\r\n\r\n  for (let i = 0; i < memory.vmTasks.length; ++i) {\r\n    memory.vmTasks[i] = {\r\n      state: 0,\r\n      next_state: 0,\r\n      offset: -1,\r\n      next_offset: -1,\r\n      stack: [],\r\n    };\r\n  }\r\n\r\n  memory.vmTasks[0].offset = 0;\r\n  memory.vmVars[0] = pos;\r\n}\r\n\r\nfunction get_page(num: number): number {\r\n  if (num == 0xff) {\r\n    return current_page2;\r\n  } else if (num == 0xfe) {\r\n    return current_page1;\r\n  } else {\r\n    console.assert(num < 4);\r\n    return num;\r\n  }\r\n}\r\n\r\nfunction fill_page(num: number, color: number) {\r\n  // console.log(`Script::op_fillPage(${num}, ${color})`)\r\n  num = get_page(num);\r\n  buffer8.fill(color, num * PAGE_SIZE, (num + 1) * PAGE_SIZE);\r\n}\r\n\r\nfunction copy_page(src: number, dst: number, vscroll: number) {\r\n  dst = get_page(dst);\r\n  if (src >= 0xfe) {\r\n    src = get_page(src);\r\n    buffer8.set(\r\n      buffer8.subarray(src * PAGE_SIZE, (src + 1) * PAGE_SIZE),\r\n      dst * PAGE_SIZE\r\n    );\r\n  } else {\r\n    if ((src & 0x80) == 0) {\r\n      vscroll = 0;\r\n    }\r\n    src = get_page(src & 3);\r\n    if (dst == src) {\r\n      return;\r\n    }\r\n    const dst_offset = dst * PAGE_SIZE;\r\n    const src_offset = src * PAGE_SIZE;\r\n    if (vscroll == 0) {\r\n      buffer8.set(\r\n        buffer8.subarray(src_offset, src_offset + PAGE_SIZE),\r\n        dst_offset\r\n      );\r\n    } else {\r\n      //console.log( 'vscroll:' + vscroll );\r\n      vscroll *= SCALE;\r\n      if (vscroll > -SCREEN_W && vscroll < SCREEN_W) {\r\n        const h = vscroll * SCREEN_W;\r\n        if (vscroll < 0) {\r\n          buffer8.set(\r\n            buffer8.subarray(src_offset - h, src_offset + PAGE_SIZE),\r\n            dst_offset\r\n          );\r\n        } else {\r\n          buffer8.set(\r\n            buffer8.subarray(src_offset, src_offset + PAGE_SIZE - h),\r\n            dst_offset + h\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction draw_point(page: number, color: number, x: number, y: number) {\r\n  if (x < 0 || x >= SCREEN_W || y < 0 || y >= SCREEN_H) {\r\n    return;\r\n  }\r\n  const offset = page * PAGE_SIZE + y * SCREEN_W + x;\r\n  if (color == 0x11) {\r\n    console.assert(page != 0);\r\n    buffer8[offset] = buffer8[y * SCREEN_W + x];\r\n  } else if (color == 0x10) {\r\n    buffer8[offset] |= 8;\r\n  } else {\r\n    console.assert(color < 0x10);\r\n    buffer8[offset] = color;\r\n  }\r\n}\r\n\r\nfunction draw_line(\r\n  page: number,\r\n  color: number,\r\n  y: number,\r\n  x1: number,\r\n  x2: number\r\n) {\r\n  if (x1 > x2) {\r\n    const tmp = x1;\r\n    x1 = x2;\r\n    x2 = tmp;\r\n  }\r\n  if (x1 >= SCREEN_W || x2 < 0) {\r\n    return;\r\n  }\r\n  if (x1 < 0) {\r\n    x1 = 0;\r\n  }\r\n  if (x2 >= SCREEN_W) {\r\n    x2 = SCREEN_W - 1;\r\n  }\r\n  const offset = page * PAGE_SIZE + y * SCREEN_W;\r\n  if (color == 0x11) {\r\n    console.assert(page != 0);\r\n    buffer8.set(\r\n      buffer8.subarray(y * SCREEN_W + x1, y * SCREEN_W + x2 + 1),\r\n      offset + x1\r\n    );\r\n  } else if (color == 0x10) {\r\n    for (let i = x1; i <= x2; ++i) {\r\n      buffer8[offset + i] |= 8;\r\n    }\r\n  } else {\r\n    console.assert(color < 0x10);\r\n    buffer8.fill(color, offset + x1, offset + x2 + 1);\r\n  }\r\n}\r\n\r\nfunction draw_polygon(page: number, color: number, vertices: any) {\r\n  // scanline fill\r\n  let i = 0;\r\n  let j = vertices.length - 1;\r\n  let scanline = Math.min(vertices[i].y, vertices[j].y);\r\n  let f2 = vertices[i++].x << 16;\r\n  let f1 = vertices[j--].x << 16;\r\n  let count = vertices.length;\r\n  for (count -= 2; count != 0; count -= 2) {\r\n    const h1 = vertices[j].y - vertices[j + 1].y;\r\n    const step1 =\r\n      (((vertices[j].x - vertices[j + 1].x) << 16) / (h1 == 0 ? 1 : h1)) >> 0;\r\n    j -= 1;\r\n    const h2 = vertices[i].y - vertices[i - 1].y;\r\n    const step2 =\r\n      (((vertices[i].x - vertices[i - 1].x) << 16) / (h2 == 0 ? 1 : h2)) >> 0;\r\n    i += 1;\r\n    f1 = (f1 & 0xffff0000) | 0x7fff;\r\n    f2 = (f2 & 0xffff0000) | 0x8000;\r\n    if (h2 == 0) {\r\n      f1 += step1;\r\n      f2 += step2;\r\n    } else {\r\n      for (let k = 0; k < h2; ++k) {\r\n        if (scanline >= 0) {\r\n          draw_line(page, color, scanline, f1 >> 16, f2 >> 16);\r\n        }\r\n        f1 += step1;\r\n        f2 += step2;\r\n        scanline += 1;\r\n        if (scanline >= SCREEN_H) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction fill_polygon(\r\n  data: Uint8Array,\r\n  offset: number,\r\n  color: number,\r\n  zoom: number,\r\n  x: number,\r\n  y: number\r\n) {\r\n  const w = ((data[offset++] * zoom) / 64) >> 0;\r\n  const h = ((data[offset++] * zoom) / 64) >> 0;\r\n  const x1 = (x * SCALE - (w * SCALE) / 2) >> 0;\r\n  const x2 = (x * SCALE + (w * SCALE) / 2) >> 0;\r\n  const y1 = (y * SCALE - (h * SCALE) / 2) >> 0;\r\n  const y2 = (y * SCALE + (h * SCALE) / 2) >> 0;\r\n  if (x1 >= SCREEN_W || x2 < 0 || y1 >= SCREEN_H || y2 < 0) {\r\n    return;\r\n  }\r\n  const count = data[offset++];\r\n  console.assert((count & 1) == 0);\r\n  let vertices = new Array();\r\n  for (let i = 0; i < count; ++i) {\r\n    const vx = x1 + (((data[offset++] * zoom) / 64) >> 0) * SCALE;\r\n    const vy = y1 + (((data[offset++] * zoom) / 64) >> 0) * SCALE;\r\n    vertices.push({ x: vx, y: vy });\r\n  }\r\n  if (count == 4 && w == 0 && h <= 1) {\r\n    draw_point(current_page0, color, x1, y1);\r\n  } else {\r\n    draw_polygon(current_page0, color, vertices);\r\n  }\r\n}\r\n\r\nfunction draw_shape_parts(\r\n  data: Uint8Array,\r\n  offset: number,\r\n  zoom: number,\r\n  x: number,\r\n  y: number\r\n) {\r\n  const x0 = (x - (data[offset++] * zoom) / 64) >> 0;\r\n  const y0 = (y - (data[offset++] * zoom) / 64) >> 0;\r\n  const count = data[offset++];\r\n  for (let i = 0; i <= count; ++i) {\r\n    const addr = (data[offset] << 8) | data[offset + 1];\r\n    offset += 2;\r\n    const x1 = (x0 + (data[offset++] * zoom) / 64) >> 0;\r\n    const y1 = (y0 + (data[offset++] * zoom) / 64) >> 0;\r\n    let color = 0xff;\r\n    if (addr & 0x8000) {\r\n      color = data[offset] & 0x7f;\r\n      offset += 2;\r\n    }\r\n    draw_shape(data, (addr << 1) & 0xfffe, color, zoom, x1, y1);\r\n  }\r\n}\r\n\r\nfunction draw_shape(\r\n  data: Uint8Array,\r\n  offset: number,\r\n  color: number,\r\n  zoom: number,\r\n  x: number,\r\n  y: number\r\n) {\r\n  const code = data[offset++];\r\n  if (code >= 0xc0) {\r\n    if (color & 0x80) {\r\n      color = code & 0x3f;\r\n    }\r\n    fill_polygon(data, offset, color, zoom, x, y);\r\n  } else {\r\n    if ((code & 0x3f) == 2) {\r\n      draw_shape_parts(data, offset, zoom, x, y);\r\n    }\r\n  }\r\n}\r\n\r\nfunction put_pixel(page: number, x: number, y: number, color: number) {\r\n  let offset = page * PAGE_SIZE + (y * SCREEN_W + x) * SCALE;\r\n  for (let j = 0; j < SCALE; ++j) {\r\n    buffer8.fill(color, offset, offset + SCALE);\r\n    offset += SCREEN_W;\r\n  }\r\n}\r\n\r\nfunction draw_char(\r\n  page: number,\r\n  chr: number,\r\n  color: number,\r\n  x: number,\r\n  y: number\r\n) {\r\n  if (x < 320 / 8 && y < 200 - 8) {\r\n    for (let j = 0; j < 8; ++j) {\r\n      const mask = font[(chr - 32) * 8 + j];\r\n      for (let i = 0; i < 8; ++i) {\r\n        if ((mask & (1 << (7 - i))) != 0) {\r\n          put_pixel(page, x * 8 + i, y + j, color);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction draw_string(num: number, color: number, x: number, y: number) {\r\n  let strings: Record<string, string> = strings_en;\r\n  if (strings_language == STRINGS_LANGUAGE.FR && num in strings_fr) {\r\n    strings = strings_fr;\r\n  }\r\n  if (num in strings) {\r\n    const str = strings[num];\r\n    draw_text(str, color, x, y);\r\n  }\r\n}\r\n\r\nexport function draw_text(str: string, color: number, x: number, y: number) {\r\n  const x0 = x;\r\n  for (let i = 0; i < str.length; ++i) {\r\n    const chr = str.charCodeAt(i);\r\n    if (chr == 10) {\r\n      y += 8;\r\n      x = x0;\r\n    } else {\r\n      draw_char(current_page0, chr, color, x, y);\r\n      x += 1;\r\n    }\r\n  }\r\n}\r\n\r\nfunction draw_bitmap(num: number) {\r\n  const bitmap = DATA.bitmaps[num] as any;\r\n  const size = bitmap[1];\r\n  console.assert(size == 32000);\r\n  const buf = load(bitmap[0], size)!;\r\n  let offset = 0;\r\n  for (let y = 0; y < 200; ++y) {\r\n    for (let x = 0; x < 320; x += 8) {\r\n      for (let b = 0; b < 8; ++b) {\r\n        const mask = 1 << (7 - b);\r\n        let color = 0;\r\n        for (let p = 0; p < 4; ++p) {\r\n          if (buf[offset + p * 8000] & mask) {\r\n            color |= 1 << p;\r\n          }\r\n        }\r\n        put_pixel(0, x + b, y, color);\r\n      }\r\n      offset += 1;\r\n    }\r\n  }\r\n}\r\n\r\nfunction update_display(num: number) {\r\n  if (num != 0xfe) {\r\n    if (num == 0xff) {\r\n      const tmp = current_page1;\r\n      current_page1 = current_page2;\r\n      current_page2 = tmp;\r\n    } else {\r\n      current_page1 = get_page(num);\r\n    }\r\n  }\r\n  if (next_palette != -1) {\r\n    const offset = next_palette * 32;\r\n    palette.set_palette_444(offset, palette.PALETTE_TYPE.AMIGA);\r\n    palette.set_palette_ega(offset + 1024);\r\n    palette.set_palette_444(offset + 1024, palette.PALETTE_TYPE.VGA);\r\n    next_palette = -1;\r\n  }\r\n\r\n  screen.update(\r\n    buffer8,\r\n    current_page1 * PAGE_SIZE // offset\r\n  );\r\n}\r\n\r\nconst vm = {\r\n  [OP_CODE.movConst]() {\r\n    const num = read_byte();\r\n    const imm = to_signed(read_word(), 16);\r\n    memory.vmVars[num] = imm;\r\n  },\r\n  [OP_CODE.mov]() {\r\n    const dst = read_byte();\r\n    const src = read_byte();\r\n    memory.vmVars[dst] = memory.vmVars[src];\r\n  },\r\n  [OP_CODE.add]() {\r\n    const dst = read_byte();\r\n    const src = read_byte();\r\n    memory.vmVars[dst] += memory.vmVars[src];\r\n  },\r\n  [OP_CODE.addConst]() {\r\n    // gun sound workaround\r\n    // if (current_part === GAME_PART.BATHS) {\r\n    //   sound.play_sound(0x5B, 1, 64, 1);\r\n    // }\r\n\r\n    const num = read_byte();\r\n    const imm = to_signed(read_word(), 16);\r\n    memory.vmVars[num] += imm;\r\n  },\r\n  [OP_CODE.call]() {\r\n    const addr = read_word();\r\n    memory.vmTasks[task_num].stack.push(bytecode_offset);\r\n    bytecode_offset = addr;\r\n  },\r\n  [OP_CODE.ret]() {\r\n    bytecode_offset = memory.vmTasks[task_num].stack.pop()!;\r\n  },\r\n  [OP_CODE.pauseThread]() {\r\n    task_paused = true;\r\n  },\r\n  [OP_CODE.jmp]() {\r\n    bytecode_offset = read_word();\r\n  },\r\n  [OP_CODE.setSetVect]() {\r\n    const num = read_byte();\r\n    const addr = read_word();\r\n    memory.vmTasks[num].next_offset = addr;\r\n  },\r\n  [OP_CODE.jnz]() {\r\n    const num = read_byte();\r\n    memory.vmVars[num] -= 1;\r\n    const addr = read_word();\r\n    if (memory.vmVars[num] != 0) {\r\n      bytecode_offset = addr;\r\n    }\r\n  },\r\n  [OP_CODE.condJmp]() {\r\n    const op = read_byte();\r\n    const b = memory.vmVars[read_byte()];\r\n    let a;\r\n    if (op & 0x80) {\r\n      a = memory.vmVars[read_byte()];\r\n    } else if (op & 0x40) {\r\n      a = to_signed(read_word(), 16);\r\n    } else {\r\n      a = read_byte();\r\n    }\r\n    const addr = read_word();\r\n    switch (op & 7) {\r\n      case 0:\r\n        if (b == a) {\r\n          bytecode_offset = addr;\r\n        }\r\n        break;\r\n      case 1:\r\n        if (b != a) {\r\n          bytecode_offset = addr;\r\n        }\r\n        break;\r\n      case 2:\r\n        if (b > a) {\r\n          bytecode_offset = addr;\r\n        }\r\n        break;\r\n      case 3:\r\n        if (b >= a) {\r\n          bytecode_offset = addr;\r\n        }\r\n        break;\r\n      case 4:\r\n        if (b < a) {\r\n          bytecode_offset = addr;\r\n        }\r\n        break;\r\n      case 5:\r\n        if (b <= a) {\r\n          bytecode_offset = addr;\r\n        }\r\n        break;\r\n    }\r\n  },\r\n  [OP_CODE.setPalette]() {\r\n    next_palette = read_word() >> 8;\r\n  },\r\n  [OP_CODE.resetThread]() {\r\n    const start = read_byte();\r\n    const end = read_byte();\r\n    const state = read_byte();\r\n    if (state == 2) {\r\n      for (let i = start; i <= end; ++i) {\r\n        memory.vmTasks[i].next_offset = -2;\r\n      }\r\n    } else {\r\n      console.assert(state == 0 || state == 1);\r\n      for (let i = start; i <= end; ++i) {\r\n        memory.vmTasks[i].next_state = state;\r\n      }\r\n    }\r\n  },\r\n  [OP_CODE.selectVideoPage]() {\r\n    const num = read_byte();\r\n    current_page0 = get_page(num);\r\n  },\r\n  [OP_CODE.fillVideoPage]() {\r\n    const num = read_byte();\r\n    const color = read_byte();\r\n    fill_page(num, color);\r\n  },\r\n  [OP_CODE.copyVideoPage]() {\r\n    const src = read_byte();\r\n    const dst = read_byte();\r\n    copy_page(src, dst, memory.vmVars[VAR.SCROLL_Y]);\r\n  },\r\n  [OP_CODE.blitFramebuffer]() {\r\n    const pageId = read_byte();\r\n\r\n    const fastMode = controls.is_key_pressed(KEY_CODE.FF);\r\n\r\n    if (!fastMode && memory.vmVars[VAR.PAUSE_SLICES] !== 0) {\r\n      const delay = Date.now() - timestamp;\r\n\r\n      // The bytecode will set vmVariables[VM_VARIABLE_PAUSE_SLICES] from 1 to 5\r\n      // The virtual machine hence indicate how long the image should be displayed.\r\n      const timeToSleep =\r\n        (memory.vmVars[VAR.PAUSE_SLICES] * 1000) / FPS - delay;\r\n\r\n      if (timeToSleep > 0) {\r\n        const t = timestamp + timeToSleep;\r\n        while (timestamp < t) {\r\n          timestamp = Date.now();\r\n        }\r\n      }\r\n    }\r\n\r\n    timestamp = Date.now();\r\n\r\n    memory.vmVars[VAR.WTF] = 0;\r\n    update_display(pageId);\r\n  },\r\n  [OP_CODE.killThread]() {\r\n    bytecode_offset = -1;\r\n    task_paused = true;\r\n  },\r\n  [OP_CODE.drawString]() {\r\n    const num = read_word();\r\n    const x = read_byte();\r\n    const y = read_byte();\r\n    const color = read_byte();\r\n    draw_string(num, color, x, y);\r\n  },\r\n  [OP_CODE.sub]() {\r\n    const dst = read_byte();\r\n    const src = read_byte();\r\n    memory.vmVars[dst] -= memory.vmVars[src];\r\n  },\r\n  [OP_CODE.and]() {\r\n    const num = read_byte();\r\n    const imm = read_word();\r\n    memory.vmVars[num] = to_signed(memory.vmVars[num] & imm & 0xffff, 16);\r\n  },\r\n  [OP_CODE.or]() {\r\n    const num = read_byte();\r\n    const imm = read_word();\r\n    memory.vmVars[num] = to_signed((memory.vmVars[num] | imm) & 0xffff, 16);\r\n  },\r\n  [OP_CODE.shl]() {\r\n    const num = read_byte();\r\n    const imm = read_word() & 15;\r\n    memory.vmVars[num] = to_signed((memory.vmVars[num] << imm) & 0xffff, 16);\r\n  },\r\n  [OP_CODE.shr]() {\r\n    // shr\r\n    const num = read_byte();\r\n    const imm = read_word() & 15;\r\n    memory.vmVars[num] = to_signed((memory.vmVars[num] & 0xffff) >> imm, 16);\r\n  },\r\n  [OP_CODE.playSound]() {\r\n    const num = read_word();\r\n    const freq = read_byte();\r\n    const volume = read_byte();\r\n    const channel = read_byte();\r\n    sound.play_sound(num, freq, volume, channel);\r\n  },\r\n  [OP_CODE.updateMemList]() {\r\n    const num = read_word();\r\n    if (num > GAME_PART.PROTECTION) {\r\n      next_part = num;\r\n    } else if (num in DATA!.bitmaps) {\r\n      if (num >= 3000) {\r\n        // should also load t3%d.bmp files for transparency (color 0x10)\r\n        const bitmap = DATA.bitmaps[num] as string[];\r\n        palette.set_palette_bmp(load(bitmap[0], 256 * 3)!);\r\n        buffer8.set(load(bitmap[1], SCREEN_W * SCREEN_H)!);\r\n      } else {\r\n        draw_bitmap(num);\r\n      }\r\n    }\r\n  },\r\n  [OP_CODE.playMusic]() {\r\n    const num = read_word();\r\n    const period = read_word();\r\n    const position = read_byte();\r\n    sound.play_music(num, period, position);\r\n  },\r\n};\r\n\r\n// PUBLIC API\r\nexport function get_state(): State {\r\n  return {\r\n    part: current_part,\r\n    vars: memory.vmVars.slice(),\r\n    tasks: JSON.parse(JSON.stringify(memory.vmTasks)),\r\n    buffer8: buffer8.slice(),\r\n    palette32: palette.palette32.slice(),\r\n  };\r\n}\r\n\r\nexport function restore_state(state: State) {\r\n  memory.vmVars.splice(0, memory.vmVars.length, ...state.vars);\r\n  memory.vmTasks.splice(0, memory.vmTasks.length, ...state.tasks);\r\n  buffer8 = state.buffer8;\r\n  palette.set_palette32(state.palette32);\r\n}\r\n\r\nexport function reset() {\r\n  current_page2 = 1;\r\n  current_page1 = 2;\r\n  current_page0 = get_page(0xfe);\r\n  buffer8.fill(0);\r\n  next_palette = -1;\r\n  memory.vmVars.fill(0);\r\n\r\n  memory.vmVars[VAR.RANDOM_SEED] = Date.now();\r\n  // memory.vmVars[VAR.HACK_VAR_54] = 0x0081;\r\n\r\n  if (BYPASS_PROTECTION) {\r\n    memory.vmVars[VAR.HACK_VAR_BC] = 0x10;\r\n    memory.vmVars[VAR.HACK_VAR_C6] = 0x80;\r\n    memory.vmVars[VAR.HACK_VAR_F2] = 4000; // 4000 for Amiga bytecode\r\n    memory.vmVars[VAR.HACK_VAR_DC] = 33;\r\n  }\r\n  memory.vmVars[VAR.HACK_VAR_E4] = 20;\r\n\r\n  next_part =\r\n    isDemo || BYPASS_PROTECTION ? GAME_PART.INTRODUCTION : GAME_PART.PROTECTION;\r\n  sound.player?.stopMusic();\r\n}\r\n\r\nexport function change_part(num: number, pos = 0) {\r\n  next_part = num;\r\n  restart(next_part, pos);\r\n  current_part = next_part;\r\n  next_part = 0;\r\n}\r\n\r\n// const restartPos: any = [\r\n// \t[16008,  0],\r\n//   [16001,  0],\r\n//   [16002, 10],\r\n//   [16002, 12],\r\n//   [16002, 14],\r\n// \t[16003, 20],\r\n//   [16003, 24],\r\n//   [16003, 26],\r\n//   [16004, 30],\r\n//   [16004, 31],\r\n// \t[16004, 32],\r\n//   [16004, 33],\r\n//   [16004, 34],\r\n//   [16004, 35],\r\n//   [16004, 36],\r\n// \t[16004, 37],\r\n//   [16004, 38],\r\n//   [16004, 39],\r\n//   [16004, 40],\r\n//   [16004, 41],\r\n// \t[16004, 42],\r\n//   [16004, 43],\r\n//   [16004, 44],\r\n//   [16004, 45],\r\n//   [16004, 46],\r\n// \t[16004, 47],\r\n//   [16004, 48],\r\n//   [16004, 49],\r\n//   [16006, 64],\r\n//   [16006, 65],\r\n// \t[16006, 66],\r\n//   [16006, 67],\r\n//   [16006, 68],\r\n//   [16005, 50],\r\n//   [16006, 60],\r\n// \t[16007, 0]\r\n// ];\r\n\r\n// export function next() {\r\n//   const part = current_part + 1;\r\n//   if (part in partsList) {\r\n//     change_part(part);\r\n//   }\r\n// }\r\n\r\n// export function prev() {\r\n//   const part = current_part - 1;\r\n//   if (part in partsList) {\r\n//     change_part(part);\r\n//   }\r\n// }\r\n\r\nexport function set_language(num: number) {\r\n  strings_language = num;\r\n}\r\n\r\nexport async function init(canvas: HTMLCanvasElement) {\r\n  screen.init(canvas, SCREEN_W, SCREEN_H, SCALE);\r\n  await sound.init();\r\n\r\n  sound.player?.setModifyVarCallback((variable: number, value: number) => {\r\n    memory.vmVars[variable] = value;\r\n  });\r\n\r\n  controls.bind_events();\r\n  reset();\r\n}\r\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import Stats from 'stats.js';\r\n\r\nimport * as sound from './sound';\r\nimport * as vm from './vm';\r\n\r\nimport type { State } from './vm';\r\nimport { GAME_PART } from '../resources';\r\n\r\nlet stats: Stats;\r\n\r\nlet timer: number | null = null;\r\n\r\nlet saved_state: State;\r\n\r\nconst rewind_buffer: State[] = new Array();\r\nlet rewind_timestamp: number;\r\n\r\nconst REWIND_SIZE = 50;\r\nconst REWIND_INTERVAL = 1000;\r\n\r\nlet prevPart: number | null = null;\r\n\r\nfunction tick() {\r\n  const current = Date.now();\r\n\r\n  stats.begin();\r\n  vm.run_tasks();\r\n  stats.end();\r\n\r\n  if (rewind_timestamp + REWIND_INTERVAL < current) {\r\n    if (rewind_buffer.length == REWIND_SIZE) {\r\n      rewind_buffer.shift();\r\n    }\r\n    rewind_buffer.push(vm.get_state());\r\n    rewind_timestamp = Date.now();\r\n  }\r\n\r\n  timer = requestAnimationFrame(tick);\r\n}\r\n\r\nexport function start() {\r\n  stats = new Stats();\r\n  stats.showPanel(1); // 0: fps, 1: ms, 2: mb, 3+: custom\r\n  document.body.appendChild(stats.dom);\r\n\r\n  rewind_timestamp = Date.now();\r\n  rewind_buffer.length = 0;\r\n\r\n  tick();\r\n\r\n  // setInterval(() => {\r\n  //   vm.draw_text(\"Another World JS\", 20, 20, 0x0f);\r\n  // }, 1000);\r\n}\r\n\r\nexport function stop() {\r\n  if (timer) {\r\n    cancelAnimationFrame(timer);\r\n  }\r\n\r\n  stats.dom.remove();\r\n  timer = null;\r\n  sound.player?.pause();\r\n  return true;\r\n}\r\n\r\nexport function pause() {\r\n  if (timer) {\r\n    cancelAnimationFrame(timer);\r\n    timer = null;\r\n    sound.player?.pause();\r\n    return true;\r\n  }\r\n\r\n  sound.player?.resume();\r\n  tick();\r\n  return false;\r\n}\r\n\r\nexport function rewind() {\r\n  if (rewind_buffer.length != 0) {\r\n    let state = rewind_buffer.pop()!;\r\n    vm.restore_state(state);\r\n  }\r\n}\r\n\r\nexport function code() {\r\n  if (prevPart) {\r\n    vm.change_part(prevPart);\r\n    prevPart = null;\r\n  } else {\r\n    sound.player?.pause();\r\n    const { part } = vm.get_state();\r\n    prevPart = part;\r\n    vm.change_part(GAME_PART.CODE);\r\n  }\r\n}\r\n\r\nexport function save() {\r\n  saved_state = vm.get_state();\r\n}\r\n\r\nexport function load() {\r\n  if (saved_state) {\r\n    vm.restore_state(saved_state);\r\n  }\r\n}\r\n\r\nexport function reset() {\r\n  vm.reset();\r\n  rewind_timestamp = Date.now();\r\n  rewind_buffer.length = 0;\r\n}\r\n","import { LitElement, html } from 'lit';\nimport { customElement } from 'lit/decorators.js';\nimport { Router } from '@vaadin/router';\n\nimport { engine, vm } from '../another/vm';\n\n@customElement('app-game')\nexport class AppGame extends LitElement {\n  createRenderRoot() {\n    return this;\n  }\n\n  firstUpdated() {\n    this.onStart();\n  }\n\n  connectedCallback(): void {\n    super.connectedCallback();\n    document.addEventListener('keyup', this.onKeypress as any);\n\n    // gamePadController.setup((gamepad: any) => {\n    //   gamepad.after('button16', () => this.onStop());\n\n    //   gamepad.after('button8', engine.code);\n    //   gamepad.after('button9', engine.pause);\n    //   gamepad.after('button4', engine.rewind);\n    //   gamepad.after('button3', screen.toggle_resolution);\n\n    //   gamepad.after('button7', engine.save);\n    //   gamepad.after('button6', engine.load);\n\n    //   gamepad.after('button12', () => {\n    //     let { part } = vm.get_state();\n    //     part = Math.min(part + 1, 16008);\n    //     vm.change_part(part, 0);\n    //   });\n\n    //   gamepad.after('button13', () => {\n    //     let { part } = vm.get_state();\n    //     part = Math.max(part - 1, 16000);\n    //     vm.change_part(part, 0);\n    //   });\n\n    //   // gamepad.after(\"button14\", () => {\n    //   //   restartIndex--;\n    //   //   if (restartIndex < 0) {\n    //   //     restartIndex = restartPos.length - 1;\n    //   //   }\n    //   //   const [part, pos] = restartPos[restartIndex];\n    //   //   vm.change_part(part, pos);\n    //   // });\n\n    //   // gamepad.after(\"button15\", () => {\n    //   //   restartIndex++;\n    //   //   if (restartIndex >= restartPos.length) {\n    //   //     restartIndex = 0;\n    //   //   }\n    //   //   const [part, pos] = restartPos[restartIndex];\n    //   //   vm.change_part(part, pos);\n    //   // });\n    // });\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    document.removeEventListener('keyup', this.onKeypress as any);\n    // gamePadController.clearEvents();\n    this.onStop();\n  }\n\n  render() {\n    return html`\n      <div id=\"app-index__canvas-container\">\n        <canvas id=\"screen\" width=\"960\" height=\"600\"></canvas>\n      </div>\n    `;\n  }\n\n  async onStart() {\n    const canvas = this.querySelector('#screen') as HTMLCanvasElement;\n    await vm.init(canvas);\n    engine.start();\n  }\n\n  onStop() {\n    engine.stop();\n    Router.go('');\n  }\n\n  onKeypress = (e: KeyboardEvent) => {\n    switch (e.key) {\n      case 'r':\n        engine.reset();\n        break;\n      case 'p':\n        engine.pause();\n        break;\n      case 'c':\n        engine.code();\n        break;\n    }\n  }\n}\n"],"names":["SCREEN_W","SCREEN_H","palette.palette32","palette.palette_type","palette.palette_bmp","memory.vmVars","read_be_uint16","memory.vmTasks","controls.pollGamepads","controls.update_input","palette.set_palette","palette.set_palette_444","palette.PALETTE_TYPE","palette.set_palette_ega","screen.update","controls.is_key_pressed","sound.play_sound","palette.set_palette_bmp","sound.play_music","sound.player","screen.init","sound.init","controls.bind_events","reset","this","vm.run_tasks","vm.get_state","vm.change_part","vm.reset","LitElement","engine.reset","engine.pause","engine.code","html","vm.init","engine.start","engine.stop","customElement"],"mappings":"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,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,GACxE,GAAM,GAAM,EAAM,EAAM,EAAM,EAAM,GAAM,GAAM,GAAM,EAAM,EAAM,IAAM,IACxE,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,IACxE,EAAM,IAAM,IAAM,EAAM,EAAM,GAAM,GAAM,IAAM,EAAM,IAAM,IAAM,EAAM,GACxE,EAAM,IAAM,IAAM,EAAM,EAAM,GAAM,GAAM,GAAM,IAAM,EAAM,EAAM,EAAM,IACxE,IAAM,IAAM,EAAM,EAAM,IAAM,IAAM,EAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IACxE,IAAM,EAAM,IAAM,EAAM,EAAM,EAAM,GAAM,GAAM,GAAM,EAAM,IAAM,IAAM,IACxE,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,EAAM,EAAM,IAAM,EACxE,EAAM,GAAM,GAAM,EAAM,EAAM,GAAM,GAAM,EAAM,EAAM,EAAM,GAAM,GAAM,EACxE,GAAM,GAAM,GAAM,EAAM,EAAM,GAAM,GAAM,GAAM,EAAM,EAAM,EAAM,EAAM,EACxE,IAAM,EAAM,EAAM,IAAM,EAAM,EAAM,GAAM,GAAM,EAAM,EAAM,EAAM,GAAM,GACxE,EAAM,IAAM,IAAM,EAAM,GAAM,GAAM,EAAM,GAAM,EAAM,GAAM,GAAM,GAAM,GACxE,GAAM,GAAM,GAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IACxE,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IACxE,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,GAAM,GACxE,IAAM,GAAM,GAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EACxE,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IACxE,IAAM,IAAM,EAAM,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,IAAM,EAAM,EAAM,EACxE,EAAM,EAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IACxE,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IACxE,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IACxE,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IACxE,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IACxE,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,EACxE,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IACxE,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,EAAM,IAAM,IACxE,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,IACxE,EAAM,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,IAAM,EAAM,EAAM,GACxE,GAAM,GAAM,IAAM,EAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,GACxE,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GACxE,GAAM,EAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,EAAM,EAAM,EACxE,EAAM,EAAM,EAAM,EAAM,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EACxE,EAAM,EAAM,GAAM,EAAM,GAAM,GAAM,GAAM,EAAM,GAAM,GAAM,IAAM,GAAM,GACxE,GAAM,IAAM,EAAM,EAAM,EAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,EAAM,EACxE,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,EAAM,EAAM,GAAM,GAAM,IAAM,GAAM,GACxE,EAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,EAAM,EAAM,EAAM,GAAM,GACxE,GAAM,GAAM,EAAM,IAAM,GAAM,GAAM,GAAM,IAAM,GAAM,GAAM,GAA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"}